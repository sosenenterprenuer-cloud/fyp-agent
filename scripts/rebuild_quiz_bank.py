import os
import json
import sqlite3
import sys

# Assume QUIZ_BANK_30 array is available in a separate file or directly here.
# For simplicity and to avoid dependency errors, we define the necessary structure here.
QUIZ_BANK_30 = [
    {"question": "What is a Foreign Key (FK) primarily used for?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["To uniquely identify a record within a single table", "To establish and enforce a link between data in two tables", "To ensure data is stored as text", "To set security permissions on a table"], "correct_text": "To establish and enforce a link between data in two tables", "explanation": "Foreign keys enforce referential integrity between tables, linking a foreign key field to a primary key field."},
    {"question": "In the context of an ER Diagram, what does \"Cardinality\" define?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["The maximum number of times an entity can relate to another entity's instance", "The data type of a specific attribute", "The total number of rows in a table", "The name given to an entity set"], "correct_text": "The maximum number of times an entity can relate to another entity's instance", "explanation": "Cardinality specifies the maximum number of instances of one entity that can be associated with instances of another."},
    {"question": "What is the primary function of a Database Management System (DBMS)?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["To manage hardware components of a system", "To create, manage, and access databases", "To write application code", "To handle network traffic"], "correct_text": "To create, manage, and access databases", "explanation": "A DBMS is software designed to define, manipulate, retrieve, and manage data in a database."},
    {"question": "Which best defines a strong entity?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["An entity that relies on another entity for its primary key", "An entity that exists independently and has a unique primary key", "An entity used only for reporting purposes", "An entity that contains only foreign keys"], "correct_text": "An entity that exists independently and has a unique primary key", "explanation": "Strong entities have their own distinct primary key and are not dependent on another entity for identification."},
    {"question": "What is \"Logical Data Independence\"?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["Allows changes to the conceptual schema without affecting the external schema (views)", "Allows changes to the physical storage without affecting the conceptual schema", "Ensures data is consistent across all systems", "Separates business logic from data access code"], "correct_text": "Allows changes to the conceptual schema without affecting the external schema (views)", "explanation": "It insulates application programs from changes to the conceptual schema."},
    {"question": "What does the term \"Metadata\" refer to in a database?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["The actual data used by the applications", "The data that describes other data (data about data)", "The physical location of the database files", "Temporary data used for processing"], "correct_text": "The data that describes other data (data about data)", "explanation": "Metadata describes the structure, constraints, and nature of the data itself (e.g., table schemas)."},
    {"question": "Which of the following is NOT an advantage of a database system over file-based systems?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["Reduced data redundancy", "Ease of data sharing", "High data integrity", "Requires highly specialized personnel for setup and management"], "correct_text": "Requires highly specialized personnel for setup and management", "explanation": "While true, this is a disadvantage; the system's advantages include reducing redundancy and improving integrity."},
    {"question": "What is the primary function of the Data Definition Language (DDL) in SQL?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["To retrieve data from the database", "To insert and update data records", "To define and modify the database schema (e.g., CREATE TABLE)", "To set user permissions"], "correct_text": "To define and modify the database schema (e.g., CREATE TABLE)", "explanation": "DDL commands like CREATE, ALTER, and DROP are used to define the structure of the database."},
    {"question": "In a relational table, what does a 'Field' represent?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["A complete row/record", "A single column/attribute", "The primary key", "A database index"], "correct_text": "A single column/attribute", "explanation": "Fields (columns) represent the attributes or characteristics of the data stored in the table."},
    {"question": "In an Entity-Relationship (ER) model, what is an \"Attribute\"?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["A line connecting two entities", "A characteristic or property of an entity", "A relationship between two entities", "A complete table structure"], "correct_text": "A characteristic or property of an entity", "explanation": "Attributes are descriptive properties of an entity, such as a student's name or age."},
    {"question": "Which situation violates the theory of Functional Dependency (FD)?", "two_category": "Normalization & Dependencies", "options": ["Two rows share the same key value but have different non-key values", "A unique identifier is used as a primary key", "A column contains numeric data", "The table is in BCNF"], "correct_text": "Two rows share the same key value but have different non-key values", "explanation": "FD (X->Y) means for a given X, Y must always be the same. Different Y values for the same X is a violation."},
    {"question": "Which best defines a Functional Dependency (FD)?", "two_category": "Normalization & Dependencies", "options": ["One attribute uniquely determines another", "A many-to-many relationship", "All attributes are keys", "Attributes are entirely unrelated"], "correct_text": "One attribute uniquely determines another", "explanation": "FD (X->Y) means the value of X determines the value of Y."},
    {"question": "What is the closure of an attribute set?", "two_category": "Normalization & Dependencies", "options": ["All attributes functionally determined by the set", "Only the primary keys of the relation", "All foreign keys only", "The number of tuples in the relation"], "correct_text": "All attributes functionally determined by the set", "explanation": "The closure (X+) is the set of all attributes that X can functionally determine in the relation."},
    {"question": "If a table contains multi-valued attributes or repeating groups, which Normal Form is violated?", "two_category": "Normalization & Dependencies", "options": ["Second Normal Form (2NF)", "Third Normal Form (3NF)", "First Normal Form (1NF)", "Boyce-Codd Normal Form (BCNF)"], "correct_text": "First Normal Form (1NF)", "explanation": "1NF requires that all attributes hold only single (atomic) values, removing repeating groups and multi-valued attributes."},
    {"question": "What is the main objective of converting a table from 1NF to 2NF?", "two_category": "Normalization & Dependencies", "options": ["To remove transitive dependencies", "To remove partial dependency on a composite key", "To simplify the table structure to one column", "To add more data redundancy"], "correct_text": "To remove partial dependency on a composite key", "explanation": "2NF addresses partial dependency, where a non-key attribute depends on only part of a composite primary key."},
    {"question": "In a table with a composite primary key (A, B), if non-key attribute C depends only on A, what type of dependency exists?", "two_category": "Normalization & Dependencies", "options": ["Transitive dependency", "Partial dependency", "Full functional dependency", "Multivalued dependency"], "correct_text": "Partial dependency", "explanation": "Since C depends on only part (A) of the composite key (A, B), it is a partial dependency, violating 2NF."},
    {"question": "What type of dependency is eliminated by moving a table from 2NF to 3NF?", "two_category": "Normalization & Dependencies", "options": ["Partial dependency", "Transitive dependency", "Full functional dependency", "Trivial dependency"], "correct_text": "Transitive dependency", "explanation": "3NF eliminates transitive dependency, where a non-key attribute depends on another non-key attribute."},
    {"question": "Table: `STUDENT_GRADE(StudentID, CourseID, ProfessorName)`. PK=(StudentID, CourseID). FD: `CourseID -> ProfessorName`. Which NF is violated?", "two_category": "Normalization & Dependencies", "options": ["Third Normal Form (3NF)", "Second Normal Form (2NF)", "First Normal Form (1NF)", "Boyce-Codd Normal Form (BCNF)"], "correct_text": "Second Normal Form (2NF)", "explanation": "ProfessorName depends on only part (CourseID) of the composite key, violating 2NF."},
    {"question": "Which is allowed in 3NF?", "two_category": "Normalization & Dependencies", "options": ["Non-key attribute determines another non-key attribute", "Key determines non-key attribute", "Part of a key determines a non-key attribute", "A table contains repeating groups"], "correct_text": "Key determines non-key attribute", "explanation": "The rule requires that every non-key attribute depends only on the primary key (no transitive dependency). Key -> Non-key is allowed."},
    {"question": "What is BCNF (Boyce-Codd Normal Form) primarily designed to address?", "two_category": "Normalization & Dependencies", "options": ["Issues where a non-key attribute determines a key attribute", "Partial dependencies", "Transitive dependencies", "The presence of repeating groups"], "correct_text": "Issues where a non-key attribute determines a key attribute", "explanation": "BCNF is stricter than 3NF and ensures that every determinant (the left side of an FD) is a candidate key."},
    {"question": "If a student's mobile number column stores \"012-3456, 019-9999\" in a single cell, which Normal Form is violated?", "two_category": "Normalization & Dependencies", "options": ["Third Normal Form (3NF)", "First Normal Form (1NF)", "Second Normal Form (2NF)", "Boyce-Codd Normal Form (BCNF)"], "correct_text": "First Normal Form (1NF)", "explanation": "This is a multi-valued attribute, violating the 1NF requirement for atomic values in each cell."},
    {"question": "What does 2NF ensure regarding non-key attributes?", "two_category": "Normalization & Dependencies", "options": ["That they are fully dependent on the primary key when the key is composite", "That they only depend on other non-key attributes", "That they are always unique", "That they are always null"], "correct_text": "That they are fully dependent on the primary key when the key is composite", "explanation": "In 2NF, non-key attributes must rely on the entire composite primary key."},
    {"question": "Which is NOT a goal of database normalization?", "two_category": "Normalization & Dependencies", "options": ["To reduce data redundancy", "To avoid insertion, update, and deletion anomalies", "To increase query processing time", "To increase data integrity and consistency"], "correct_text": "To increase query processing time", "explanation": "Normalization is done to minimize redundancy and maximize integrity, which typically improves efficiency."},
    {"question": "In the table `EMPLOYEE(EmployeeID, DeptID, DeptName)`. FD: `EmployeeID -> DeptID`, `DeptID -> DeptName`. PK = `EmployeeID`. Which NF is violated?", "two_category": "Normalization & Dependencies", "options": ["Second Normal Form (2NF)", "First Normal Form (1NF)", "Third Normal Form (3NF)", "Boyce-Codd Normal Form (BCNF)"], "correct_text": "Third Normal Form (3NF)", "explanation": "DeptName depends on DeptID (Non-key -> Non-key), which is a transitive dependency violating 3NF."},
    {"question": "Which best describes the action required to fix a 3NF violation?", "two_category": "Normalization & Dependencies", "options": ["Move the non-key attribute and its determinant to a new table", "Remove the primary key", "Split the table based on repeating groups", "Add more foreign keys"], "correct_text": "Move the non-key attribute and its determinant to a new table", "explanation": "To resolve a transitive dependency, the non-key attribute and the non-key determinant must be extracted into a new relation."},
    {"question": "What is a Composite Key?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["A key used only for joins", "A key consisting of two or more attributes", "A key that can never have null values", "A key that is also a foreign key"], "correct_text": "A key consisting of two or more attributes", "explanation": "A composite key is a primary key that is made up of two or more columns."},
    {"question": "Which describes a \"Referential Integrity\" constraint?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["Ensures that every foreign key value references an existing primary key value", "Ensures all primary key values are unique", "Ensures data is always stored in BCNF", "Ensures data independence"], "correct_text": "Ensures that every foreign key value references an existing primary key value", "explanation": "Referential integrity ensures that relationships between tables remain consistent."},
    {"question": "What does a \"Domain\" specify in the relational model?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["The foreign keys in a table", "The set of permissible values for an attribute", "The name of the relation", "The primary key"], "correct_text": "The set of permissible values for an attribute", "explanation": "The domain specifies the valid range or set of values an attribute can take (e.g., Date, Integer between 1 and 100)."},
    {"question": "Which is the primary benefit of creating \"Views\" in a database?", "two_category": "Data Modeling & DBMS Fundamentals", "options": ["Views speed up data modification operations", "Views provide a customized and secure virtual representation of the data", "Views physically separate data files", "Views eliminate all data redundancy"], "correct_text": "Views provide a customized and secure virtual representation of the data", "explanation": "Views simplify complex queries and can hide sensitive columns from certain users, supporting logical data independence."},
    {"question": "What happens during the \"Decomposition\" process in normalization?", "two_category": "Normalization & Dependencies", "options": ["A single table is split into multiple, smaller tables", "Multiple tables are joined into one large table", "Non-key attributes are removed", "New functional dependencies are created"], "correct_text": "A single table is split into multiple, smaller tables", "explanation": "Decomposition is the process of breaking down a large, potentially anomalous table into smaller, well-structured relations."},
]

DB_PATH = os.environ.get("PLA_DB", "pla.db")

def rebuild_quiz_bank():
    """Wipes the quiz table and inserts the 30 clean questions from the embedded bank."""
    print(f"[REBUILD] Starting quiz bank rebuild in: {DB_PATH}")
    
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        
        # 1. Clear old quiz data and related responses
        cur.execute("DELETE FROM response")
        cur.execute("DELETE FROM quiz")
        
        # 2. Insert the 30 clean questions
        for q_data in QUIZ_BANK_30:
            options_json = json.dumps(q_data['options'][:4]) # Ensure max 4 options
            
            cur.execute("""
                INSERT INTO quiz (question, options_text, correct_answer, two_category, explanation)
                VALUES (?, ?, ?, ?, ?)
            """, (q_data['question'], options_json, q_data['correct_text'], 
                  q_data['two_category'], q_data['explanation']))

        conn.commit()
        
        # 3. Final validation
        final_count = cur.execute("SELECT COUNT(*) FROM quiz").fetchone()[0]
        fund_count = cur.execute("SELECT COUNT(*) FROM quiz WHERE two_category = 'Data Modeling & DBMS Fundamentals'").fetchone()[0]
        norm_count = cur.execute("SELECT COUNT(*) FROM quiz WHERE two_category = 'Normalization & Dependencies'").fetchone()[0]
        
        if final_count != 30:
            print(f"[ERROR] Rebuild failed: Found {final_count} questions (expected 30).")
            return
            
        print(f"[SUCCESS] Quiz bank rebuilt with 30 questions.")
        print(f"[STATUS] Fundamentals: {fund_count} | Normalization: {norm_count}")
        
    except sqlite3.Error as e:
        print(f"[FATAL DB ERROR] Unable to rebuild quiz bank: {e}")
        sys.exit(1)
    finally:
        if 'conn' in locals() and conn:
            conn.close()

if __name__ == "__main__":
    rebuild_quiz_bank()